from django.test import TestCase
from base.models import Show, Talent, Genre, Review, Theater
from django.contrib.auth.models import User
from random import randint
from datetime import datetime



""" We will only test the function or logic made by us, not by the framework. The use case is when someone
modify the code and he accidentally change the model definition ( such as max_length), the test will capture it. 
"""


# The helper class might be moved to different file in the future.

class Helper : 

    def generate_simple_names(self,modelname,length): 
        return [f"{modelname} {x}" for x in range(length)]
    def generate_string(self,length): 
        """generate random string with specified length"""
        chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        result = ""
        for i in range(length+2): 
            result += chars[randint(0,len(chars)-1)] # generate random chars           
        return result 
    def generate_user_object(self,length): 
        user_names = self.generate_simple_names("user",length)
        result = []
        return ([User.objects.create(
                username=name,
                password=f"{name}123"
        )
        for name in user_names])
    def generate_genre_object(self,length): 
        genre_names = self.generate_simple_names("genre",length)
        return [Genre.objects.create(name=name) for name in genre_names]
    def generate_talent_object(self,length): 
        talent_names = self.generate_simple_names("talent",length)
        return [Talent.objects.create(name=name) for name in talent_names]
    def generate_theater_object(self,length): 
        theater_names = self.generate_simple_names("theater",length)
        user_objects = self.generate_user_object(length)
        return ([Theater.objects.create(
            name=name,
            user=user
        ) for name,user in zip(theater_names,user_objects)])



class TalentTestCase(TestCase): 
    """ Unit Testing for Talent Model """
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.talent = Talent.objects.create(name="agus")    
   
    def test_talent_object_string_repr(self):
        """test whether the string representation of talent object is obtained from its name attribute"""
        talent = Talent.objects.get(id=1)
        self.assertEqual(str(talent),"agus")
    
    def test_field_max_length(self): 
        """ test whether the max length of the field(s) are according to model definition  """
        talent = Talent.objects.get(id=1)
        name_max_length = talent._meta.get_field("name").max_length
        self.assertEqual(name_max_length,100)
    
    
               

class GenreTestCase(TestCase): 
    """ Unit testing for Genre Model """
    @classmethod
    def setUpClass(cls): 
        super().setUpClass()
        cls.genre = Genre.objects.create(name="Comedy")
    
    def test_object_string_repr(self): 
        """test whether the string representation of genre object is obtained from its name attribute"""
        genre = Genre.objects.get(id=1)
        self.assertEqual(str(genre),"Comedy")
    
    def test_field_max_length(self): 
        """ test whether the max length of the field(s) are according to model definition  """
        genre = Genre.objects.get(id=1)
        name_max_length = genre._meta.get_field("name").max_length
        self.assertEqual(name_max_length,50)

class TheaterTestCase(TestCase): 
    """ Unit Testing for Theater Model """
    @classmethod
    def setUpClass(cls): 
        super().setUpClass() 
        cls.user = User.objects.create(username="agus",password="agus123")
    
    def setUp(self): 
        self.theater = Theater.objects.create(
            name = "Theater 1", 
            user = self.user
        )
        self.user2 = User.objects.create(username="budi", password="budi123")
        self.theater2 = Theater.objects.create(
            name = "Theater 2",
            user = self.user2
        )
    
    def test_object_string_repr(self): 
        """test whether the string representation of genre object is obtained from its name attribute"""
        theater1 = Theater.objects.get(id=1)
        self.assertEqual(str(theater1.name),"Theater 1")
    
    def test_on_delete_relation(self): 
        """ test whether on_delete mechanism of related object is according to model definition """
        theater2_qs = Theater.objects.filter(name="Theater 2") # create Theather Query Set 
        self.assertEqual(len(theater2_qs),1)
  
        User.objects.get(username="budi").delete() # delete user2, which is associated with theater2
        empty_theater_qs = Theater.objects.filter(name="Theater 2") 
        self.assertEqual(len(empty_theater_qs),0)

class ShowTestCase(TestCase): 
    """ Unit testing for Show model """
    @classmethod
    def setUpClass(cls): 
        super().setUpClass()
        cls.helper = Helper()
    def setUp(self): 
        self.genres = self.helper.generate_genre_object(2) # generate 2 objects
        self.talents = self.helper.generate_talent_object(2)
        self.theaters = self.helper.generate_theater_object(2)
        self.show1 = Show.objects.create(
            name = "Amazing Show 1",
            host = self.theaters[0],
            description = "The only amazing show you'll ever need",
        )
        self.show1.genre.set(self.genres)
        self.show1.talent.set(self.talents)

        self.show2 = Show.objects.create(
            name="Amazing Show 2",
            host = self.theaters[1]
        )    
    def test_object_string_repr(self): 
        show1 = Show.objects.get(id=1)
        self.assertEqual(str(show1),"Amazing Show 1")
    def test_many_to_many_relationship_exists(self): 
        show1 = Show.objects.get(id=1)
        result_genre = []
        result_talent = []
        for genre,talent in zip(show1.genre.all(),show1.talent.all()):
            result_genre.append(str(genre))
            result_talent.append(str(talent))
        self.assertEqual(result_genre,["genre 0","genre 1"])
        self.assertEqual(result_talent,["talent 0","talent 1"])
    def test_on_delete_relations(self): 
        theater1 = Theater.objects.get(id=1) # get the first theater object used in show1 
        show1 = Show.objects.filter(id=1) # before theater deletion
        self.assertEqual(len(show1),1)
        theater1.delete()
        show1 = Show.objects.filter(id=1) # after theater deletion 
        self.assertEqual(len(show1),0)
    def test_create_n_update_time_automatically(self):
        show1 = Show.objects.get(id=1)
        update_date = show1.updated
        create_date = show1.created
        self.assertIsInstance(update_date,datetime)
        self.assertIsInstance(create_date,datetime)
    def test_record_ordered_from_latest_updated(self): 
        show = Show.objects.all()
        first_appeared_record = show[0]
        self.assertEqual(str(first_appeared_record),"Amazing Show 2")
        show1 = Show.objects.get(id=1) 
        show1.name = "Amazing Show 1 updated" # updating the value of show1 to check whether the ordering change 
        show1.save()
        show = Show.objects.all()
        first_appeared_record = show[0]
        self.assertEqual(str(first_appeared_record),"Amazing Show 1 updated")
    def test_custom_save_method(self): 
        show3 = Show.objects.create(
            name = "Amazing Show 3",
            host = self.theaters[0],
            description = "The third most amazing show",
        )
       
        show3.host_id = None # Test whether the logic of "if not self.host_id:    will reproduce host_id when called"
        show3.save()

        self.assertIsNotNone(show3.host_id)  #Test wether the save method will be able to reproduce host_id

        


    



    

    
